'''
Гражданская оборона

Штаб гражданской обороны Тридесятой области решил обновить план спасения
на случай ядерной атаки. Известно, что все n селений Тридесятой области
находятся вдоль одной прямой дороги. Вдоль дороги также расположены m
бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.

Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
необходимо для каждого селения определить ближайшее к нему бомбоубежище.

Формат ввода
В первой строке вводится число n - количество селений (1 <= n <= 100000).
Вторая строка содержит n различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го селения. В третьей строке входных данных
задается число m - количество бомбоубежищ (1 <= m <= 100000).
Четвертая строка содержит m различных целых чисел, i-е из этих чисел задает
расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны
и не превышают 10⁹. Селение и убежище могут располагаться в одной точке.

Формат вывода
Выведите n чисел - для каждого селения выведите номер ближайшего к нему
бомбоубежища. Бомбоубежища пронумерованы от 1 до m в том порядке,
в котором они заданы во входных данных.
'''


def nearest_s(c, ss, i=0):
    len_ss = len(ss)
    while i != len_ss - 1 and abs(c - ss[i + 1][1]) < abs(c - ss[i][1]):
        i += 1
    return i


cities_len = int(input())
cities = sorted(enumerate(map(int, input().split()), 1), key=lambda x: x[1])
shelters_len = int(input())
shelters = sorted(enumerate(map(int, input().split()), 1), key=lambda x: x[1])

nearest_s_curr = nearest_s(cities[0][1], shelters)
nearest_shelters = []

for ci, c in cities:
    nearest_s_curr = nearest_s(c, shelters, nearest_s_curr)
    nearest_shelters.append((ci, shelters[nearest_s_curr][0]))

print(*map(lambda x: x[1], sorted(nearest_shelters)))
